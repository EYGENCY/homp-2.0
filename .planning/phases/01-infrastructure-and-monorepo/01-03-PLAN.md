---
phase: 01-infrastructure-and-monorepo
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
  - 01-02
files_modified:
  - apps/api/src/index.ts
  - apps/api/package.json
  - apps/api/tsconfig.json
  - apps/web/next.config.ts
  - apps/web/package.json
  - packages/db/src/index.ts
autonomous: true
requirements:
  - INFRA-02
  - INFRA-03
  - INFRA-05

must_haves:
  truths:
    - "Hono API starts, verifies DB connection, and exits with a clear error message if DATABASE_URL is invalid or postgres is unreachable"
    - "`GET /health` returns `{\"db\": \"ok\", \"redis\": \"ok\"}` with HTTP 200 when both services are reachable"
    - "`GET /health` returns HTTP 503 when DB is unreachable"
    - "Next.js build fails with a Zod validation error (not a runtime crash) if NEXT_PUBLIC_API_URL is missing"
    - "Neither app reads `process.env` directly — all env access goes through `@homp/config`"
  artifacts:
    - path: "apps/api/src/index.ts"
      provides: "Hono app with /health endpoint and DB startup check"
      exports: []
      contains: "@homp/config"
    - path: "apps/web/next.config.ts"
      provides: "Next.js config with env validation and transpilePackages"
      contains: "transpilePackages"
    - path: "apps/api/package.json"
      provides: "API package with @homp/config and @homp/db workspace dependencies"
      contains: "@homp/config"
    - path: "apps/web/package.json"
      provides: "Web package with @homp/config workspace dependency"
      contains: "@homp/config"
  key_links:
    - from: "apps/api/src/index.ts"
      to: "@homp/config/server"
      via: "import { serverEnv } — throws at module load if env invalid"
      pattern: "from.*@homp/config"
    - from: "apps/api/src/index.ts"
      to: "@homp/db client"
      via: "await client`SELECT 1` in startup check and /health handler"
      pattern: "client`SELECT 1`"
    - from: "apps/web/next.config.ts"
      to: "@homp/config"
      via: "import at top of file triggers Zod validation at build time"
      pattern: "import.*@homp/config"
    - from: "apps/web/next.config.ts"
      to: "transpilePackages"
      via: "Required for JIT package — tells Next.js to transpile @homp/config TypeScript source"
      pattern: "transpilePackages.*@homp/config"
---

<objective>
Wire `apps/api` and `apps/web` to use `@homp/config` for all env access, implement the Hono `/health` endpoint with real DB/Redis checks, and configure Next.js to validate env at build time.

Purpose: Completes the env validation story end-to-end. The API now fails fast with a clear error if infrastructure is down. The web app catches missing NEXT_PUBLIC_* vars during build, not at runtime. Neither app reads `process.env` directly.

Output: Functional Hono API with `/health` endpoint; Next.js configured to validate env at build time; both apps depending on `@homp/config`.
</objective>

<execution_context>
@/Users/sr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-and-monorepo/01-RESEARCH.md
@.planning/phases/01-infrastructure-and-monorepo/01-01-SUMMARY.md
@.planning/phases/01-infrastructure-and-monorepo/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Hono API to @homp/config and @homp/db with /health endpoint</name>
  <files>
    apps/api/src/index.ts
    apps/api/package.json
    apps/api/tsconfig.json
  </files>
  <action>
**Step 1 — Add workspace dependencies to apps/api/package.json:**

```bash
cd /Users/sr/homp-2.0
pnpm --filter api add @homp/config@workspace:* @homp/db@workspace:*
```

Also add `ioredis` for the Redis health check (Phase 1 only — BullMQ comes in Phase 2, but we need Redis connectivity check now):
```bash
pnpm --filter api add ioredis
```

The dev script in `apps/api/package.json` should already be `tsx --env-file=../../.env watch src/index.ts` from Plan 02. Verify it is set; update if not.

**Step 2 — Rewrite apps/api/src/index.ts** (current file is the Hono scaffold stub):

```typescript
import { serve } from "@hono/node-server";
import { Hono } from "hono";
import { serverEnv } from "@homp/config/server"; // throws if any server env var is missing
import { client } from "@homp/db";
import Redis from "ioredis";

const app = new Hono();

// Health check endpoint — used by Railway and local debugging
// Returns 200 { db: "ok", redis: "ok" } when healthy
// Returns 503 { db: "error", redis: "ok"|"error" } when unhealthy
app.get("/health", async (c) => {
  // Check PostgreSQL
  let dbStatus: "ok" | "error" = "ok";
  try {
    await client`SELECT 1`;
  } catch {
    dbStatus = "error";
  }

  // Check Redis
  // Phase 1: Direct ioredis connection for health check only
  // Phase 2 will replace with the BullMQ connection instance
  let redisStatus: "ok" | "error" = "ok";
  let redis: Redis | null = null;
  try {
    redis = new Redis(serverEnv.REDIS_URL, {
      family: 0, // Required for Railway private networking (IPv6/IPv4 dual-stack)
      lazyConnect: true,
      connectTimeout: 3000,
    });
    await redis.connect();
    await redis.ping();
  } catch {
    redisStatus = "error";
  } finally {
    if (redis) {
      redis.disconnect();
    }
  }

  const httpStatus = dbStatus === "ok" ? 200 : 503;
  return c.json({ db: dbStatus, redis: redisStatus }, httpStatus);
});

// Root route — basic confirmation the API is running
app.get("/", (c) => {
  return c.json({ message: "HOMP API", version: "2.0.0" });
});

async function main() {
  // Verify DB connection before accepting traffic
  // If this fails, the process exits 1 with a clear error — no silent failures
  try {
    await client`SELECT 1`;
    console.log("✓ Database connected");
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    console.error(`✗ Cannot connect to database: ${message}`);
    console.error(
      "Ensure docker compose is running: docker compose up -d postgres"
    );
    process.exit(1);
  }

  const port = serverEnv.PORT;

  serve(
    {
      fetch: app.fetch,
      port,
    },
    (info) => {
      console.log(`HOMP API running on http://localhost:${info.port}`);
    }
  );
}

main();
```

**Step 3 — Update apps/api/tsconfig.json** to resolve workspace packages. The current tsconfig likely uses default module resolution. Ensure it handles TypeScript source imports from workspace packages:

Read the current tsconfig.json content first. Add `"moduleResolution": "Bundler"` if not present, and add `paths` for workspace packages so tsc can type-check correctly:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "strict": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "skipLibCheck": true
  },
  "include": ["src/**/*.ts"]
}
```

Note: tsx for dev handles TypeScript resolution natively via Node module resolution (reads package.json `exports` field). For tsc build, `NodeNext` + `exports` field in each package is correct. If tsc cannot resolve `@homp/config`, add the package to the root `tsconfig.json` with a `paths` entry pointing to the workspace source.
  </action>
  <verify>
With docker compose running:
```bash
cd /Users/sr/homp-2.0
# Start docker compose
docker compose up -d

# Wait for postgres to be healthy
docker compose ps postgres  # Should show "healthy"

# Start API in background to test
cd /Users/sr/homp-2.0 && pnpm --filter api dev &
sleep 5

# Test health endpoint
curl -s http://localhost:3001/health
# Expected: {"db":"ok","redis":"ok"}

# Test root
curl -s http://localhost:3001/
# Expected: {"message":"HOMP API","version":"2.0.0"}

# Kill background process
kill %1 2>/dev/null
```
  </verify>
  <done>
`apps/api/src/index.ts` imports `serverEnv` from `@homp/config/server` and `client` from `@homp/db`. `GET /health` returns `{"db":"ok","redis":"ok"}` with HTTP 200 when docker compose is running. API exits with code 1 and clear error message when DB is unreachable. `apps/api/package.json` lists `@homp/config` and `@homp/db` as workspace dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Next.js web app to validate env at build time via @homp/config</name>
  <files>
    apps/web/next.config.ts
    apps/web/package.json
  </files>
  <action>
**Step 1 — Add @homp/config as workspace dependency to apps/web:**

```bash
cd /Users/sr/homp-2.0
pnpm --filter web add @homp/config@workspace:*
```

**Step 2 — Update apps/web/next.config.ts** to:
1. Import `@homp/config` at the top — this triggers Zod validation at build time
2. Add `transpilePackages: ["@homp/config"]` — required for JIT packages (tells Next.js to transpile the TypeScript source)
3. Add `@homp/db` to transpilePackages proactively (Phase 2 will need it from the web app)

```typescript
// Importing @homp/config validates all env vars at build time via Zod.
// If any required var is missing, next build fails with a clear error before deployment.
// This is the recommended T3 Env approach for Next.js App Router.
import "@homp/config";
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  // transpilePackages: required for JIT internal packages that export TypeScript source.
  // Without this, Next.js cannot process the raw .ts files from node_modules/@homp/*.
  transpilePackages: ["@homp/config", "@homp/db"],
};

export default nextConfig;
```

**Step 3 — Verify the .env symlink for Next.js.**

Next.js looks for `.env` in its own working directory (`apps/web/`), not the monorepo root. The symlink created in Plan 02 (`apps/web/.env -> ../../.env`) ensures Next.js finds the root `.env`. Verify it exists:

```bash
ls -la /Users/sr/homp-2.0/apps/web/.env
```

If the symlink doesn't exist (Plan 02 may not have created it yet), create it:
```bash
ln -sf ../../.env /Users/sr/homp-2.0/apps/web/.env
```

**Step 4 — Verify apps/web has a minimal working page** so `next build` can run. Check `apps/web/src/app/page.tsx` exists. If it shows a default Next.js scaffold, that's fine — no changes needed for Phase 1. The web app just needs to build cleanly; real UI comes in Phase 4.
  </action>
  <verify>
```bash
cd /Users/sr/homp-2.0

# Verify @homp/config is listed in web's package.json
grep "@homp/config" apps/web/package.json

# Verify transpilePackages in next.config.ts
grep "transpilePackages" apps/web/next.config.ts

# Attempt a type-check to confirm env validation wiring
pnpm --filter web exec tsc --noEmit --skipLibCheck
# Should pass (or show only minor warnings, not env-related errors)
```
  </verify>
  <done>
`apps/web/next.config.ts` imports `@homp/config` at the top and includes `transpilePackages: ["@homp/config", "@homp/db"]`. `apps/web/package.json` lists `@homp/config` as a workspace dependency. `apps/web/.env` symlink exists pointing to `../../.env`.
  </done>
</task>

</tasks>

<verification>
1. `curl http://localhost:3001/health` returns `{"db":"ok","redis":"ok"}` when docker compose is running
2. `curl http://localhost:3001/health` returns `{"db":"error","redis":"ok"}` (or 503) when postgres is stopped
3. `apps/api/src/index.ts` contains no direct `process.env` access — only `serverEnv.*` from `@homp/config/server`
4. `apps/web/next.config.ts` contains `import "@homp/config"` and `transpilePackages`
5. `pnpm --filter api dev` starts successfully when docker compose is running
6. `pnpm dev` from monorepo root starts both Next.js and Hono concurrently via Turbo
</verification>

<success_criteria>
- `GET /health` returns 200 `{"db":"ok","redis":"ok"}` when local stack is running
- `GET /health` returns 503 when database is unreachable
- API startup with missing DATABASE_URL exits with clear Zod error message
- `next build` fails with env validation error (not a cryptic crash) when NEXT_PUBLIC_API_URL is missing
- `pnpm dev` from root starts both apps
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-and-monorepo/01-03-SUMMARY.md`
</output>
