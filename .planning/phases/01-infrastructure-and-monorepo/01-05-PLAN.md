---
phase: 01-infrastructure-and-monorepo
plan: 05
type: execute
wave: 4
depends_on:
  - 01-04
files_modified: []
autonomous: false
requirements:
  - INFRA-04

must_haves:
  truths:
    - "Railway homp-web service has a public URL and returns HTTP 200"
    - "Railway homp-api service `/health` returns `{\"db\": \"ok\", \"redis\": \"ok\"}`"
    - "Railway deployment was triggered by a push to the main branch (auto-deploy confirmed)"
    - "No secrets appear in the git commit history"
  artifacts:
    - path: "apps/api/railway.toml"
      provides: "Railway config — already created in Plan 04"
      contains: "RAILPACK"
    - path: "apps/web/railway.toml"
      provides: "Railway config — already created in Plan 04"
      contains: "RAILPACK"
  key_links:
    - from: "GitHub push to main"
      to: "Railway auto-deploy"
      via: "Railway GitHub integration triggers build on push"
      pattern: "auto-deploy"
---

<objective>
Complete Railway project setup, push all code to main, and verify the live deployment is healthy.

Purpose: Phase 1 ends with a real live Railway URL — not "it works locally." This checkpoint verifies that Railway services are running, health checks pass, and the auto-deploy pipeline is wired.

Output: Live Railway URLs for web and API; confirmed auto-deploy on push to main.
</objective>

<execution_context>
@/Users/sr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-and-monorepo/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Commit all Phase 1 work and push to main</name>
  <files></files>
  <action>
Ensure all Phase 1 work is committed and pushed to the `main` branch to trigger Railway auto-deploy.

**Step 1 — Verify nothing sensitive is staged:**
```bash
cd /Users/sr/homp-2.0
git status
# Verify .env is NOT listed (it should be gitignored)
git diff --staged --name-only | grep "\.env$" && echo "WARNING: .env staged!" || echo "OK — no .env staged"
```

**Step 2 — Stage all Phase 1 files:**
```bash
cd /Users/sr/homp-2.0
git add \
  .gitignore \
  .env.example \
  docker-compose.yml \
  turbo.json \
  package.json \
  pnpm-workspace.yaml \
  packages/config/ \
  packages/db/drizzle.config.ts \
  packages/db/package.json \
  packages/db/src/ \
  packages/db/migrations/ \
  apps/api/src/index.ts \
  apps/api/package.json \
  apps/api/tsconfig.json \
  apps/api/railway.toml \
  apps/web/next.config.ts \
  apps/web/package.json \
  apps/web/railway.toml \
  pnpm-lock.yaml
```

**Step 3 — Create commit:**
```bash
cd /Users/sr/homp-2.0
git commit -m "feat(phase-01): complete infrastructure and monorepo setup

- packages/config: Zod-validated env schemas (serverEnv + clientEnv)
- docker-compose: health checks for postgres, redis, minio
- turbo.json: globalPassThroughEnv for all env vars
- packages/db: upgrade drizzle-orm/kit to 0.45.1/0.31.9, fix config format
- packages/db: baseline migration (uuid-ossp extension)
- apps/api: /health endpoint, DB startup check, @homp/config integration
- apps/web: env validation at build time, transpilePackages
- railway.toml: Railpack config for API and web services"
```

**Step 4 — Push to main:**
```bash
cd /Users/sr/homp-2.0
git push origin main
```

This push triggers Railway auto-deploy for both homp-api and homp-web services (if Railway GitHub integration is connected).
  </action>
  <verify>
```bash
cd /Users/sr/homp-2.0
# Verify push succeeded
git log --oneline -1
# Verify .env is not tracked
git ls-files .env
# Should return nothing (empty output means .env is correctly gitignored)
```
  </verify>
  <done>
All Phase 1 code committed to main and pushed. `git ls-files .env` returns empty. Railway has received the push trigger and shows a build in progress.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Railway deployment and local stack</name>
  <action>Human verifies Railway services are live and local development stack is functional.</action>
  <verify>
1. `curl https://YOUR-API-URL.up.railway.app/health` returns `{"db":"ok","redis":"ok"}`
2. `https://YOUR-WEB-URL.up.railway.app` loads in browser without errors
3. `curl http://localhost:3001/health` returns `{"db":"ok","redis":"ok"}` on local stack
  </verify>
  <done>
Railway homp-api and homp-web services are live. Health check passes on production. Local dev stack works end-to-end.
  </done>
  <what-built>
Complete Phase 1 infrastructure:
- packages/config with Zod-validated env schemas
- docker-compose with health checks
- Drizzle upgrade + baseline migration
- Hono API with /health endpoint
- Next.js with build-time env validation
- Railway deployment configuration

Code has been pushed to main branch to trigger Railway auto-deploy.
  </what-built>
  <how-to-verify>
**Step 1 — Set up Railway project (one-time, if not done yet):**

Go to https://railway.app and create a new project named "homp-2.0":
1. Add PostgreSQL plugin — Railway names it "Postgres", provides `${{Postgres.DATABASE_URL}}`
2. Add Redis plugin — Railway names it "Redis", provides `${{Redis.REDIS_URL}}`
3. Create service "homp-api":
   - Source: this GitHub repo, branch: main
   - Leave Root Directory EMPTY (critical — shared monorepo needs repo root access)
   - Railway auto-detects `apps/api/railway.toml`
   - Set environment variables:
     - `DATABASE_URL` = `${{Postgres.DATABASE_URL}}`
     - `REDIS_URL` = `${{Redis.REDIS_URL}}`
     - `NODE_ENV` = `production`
     - `PORT` = `3001`
     - `S3_ENDPOINT`, `S3_BUCKET`, `S3_ACCESS_KEY_ID`, `S3_SECRET_ACCESS_KEY`, `S3_REGION` = Railway Storage Bucket values (or placeholders if bucket not yet created)
   - Watch paths: `apps/api/**`, `packages/config/**`, `packages/db/**`
4. Create service "homp-web":
   - Source: same GitHub repo, branch: main
   - Leave Root Directory EMPTY
   - Set environment variables:
     - `NEXT_PUBLIC_API_URL` = the Railway public domain of homp-api (set after first deploy completes)
     - `DATABASE_URL` = `${{Postgres.DATABASE_URL}}`
     - `REDIS_URL` = `${{Redis.REDIS_URL}}`
     - `NODE_ENV` = `production`
     - Same S3 vars as API
   - Watch paths: `apps/web/**`, `packages/config/**`

**Step 2 — Verify Railway deployments:**

After builds complete (monitor in Railway dashboard build logs):

```bash
# Test API health on Railway
curl https://YOUR-API-URL.up.railway.app/health
# Expected: {"db":"ok","redis":"ok"}
```

Visit `https://YOUR-WEB-URL.up.railway.app` in browser.
Expected: Next.js page loads without errors.

Verify auto-deploy: make a trivial commit (`git commit --allow-empty -m "test: verify auto-deploy"`) and push to main. Railway should start a new deployment.

**Step 3 — Verify local stack:**
```bash
cd /Users/sr/homp-2.0

# Start services
docker compose up -d

# Check health (wait ~15s for postgres to be healthy)
docker compose ps
# postgres and redis should show "healthy"

# Run baseline migration
pnpm db:migrate
# Should exit 0 with no errors

# Start dev servers
pnpm dev
# Both Next.js (http://localhost:3000) and Hono API (http://localhost:3001) start

# Test local health
curl http://localhost:3001/health
# Expected: {"db":"ok","redis":"ok"}
```
  </how-to-verify>
  <resume-signal>
Share the live Railway URLs for web and API, or describe any issues encountered. Type "approved" if all services are running.
  </resume-signal>
</task>

</tasks>

<verification>
1. `git log --oneline -1` shows the Phase 1 commit
2. `git ls-files .env` returns empty (no secrets tracked)
3. Railway homp-api: `curl https://API_URL/health` returns `{"db":"ok","redis":"ok"}`
4. Railway homp-web: root URL returns HTTP 200
5. Local: `docker compose up` + `pnpm dev` + `pnpm db:migrate` all succeed
6. `curl http://localhost:3001/health` returns `{"db":"ok","redis":"ok"}`
</verification>

<success_criteria>
- Live Railway URL exists for both web and API services
- `/health` endpoint returns `{"db":"ok","redis":"ok"}` on Railway production
- Auto-deploy triggers on push to main
- Local `pnpm dev` starts both apps concurrently from monorepo root
- `docker compose up` starts all services with passing health checks
- No secrets in git history
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-and-monorepo/01-05-SUMMARY.md`
</output>
